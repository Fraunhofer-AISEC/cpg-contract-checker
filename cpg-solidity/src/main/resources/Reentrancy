match p=(base)-[:BASE]-(c:CallExpression)-[e:EOG|INVOKES|RETURNS*]->(n)
where not exists {(c)<--(em:EmitStatement)}
and (
    exists{
        (n)-[d:DFG*]->(:FieldDeclaration)
    } or exists {
        (n)-[d:DFG*]->(bin:BinaryOperator)-[:LHS]->()-[:BASE|LHS|ARRAY_EXPRESSION*]->()<-[:DFG*]-(:FieldDeclaration)
        where bin.operatorCode in ['=', '|=', '^=', '&=', '<<=','>>=','+=', '-=', '*=', '/=', '%=']
    }
    or exists {
        (n)-[d:DFG*]->(bin:UnaryOperator)-[:INPUT|BASE|LHS|ARRAY_EXPRESSION]->()<-[:DFG*]-(:FieldDeclaration)
        where bin.operatorCode in ['++','--']
    }
) 
and(not exists  {()-[:DFG]->(b1)<-[:BASE*]-(c)} 
or exists {
    dflow=(s)-[:DFG*]->(b2)<-[:BASE*]-(c)
    where not exists (()-[:DFG]->(s)) and  not 'Literal' in labels(s) and not  exists((s)<-[:PARAMETERS]-(:ConstructorDeclaration)) and (not s.isInferred or s.name in ['msg', 'tx'] )
    and not exists{(sub)-[:DFG]->(array)-[:SUBSCRIPT_EXPRESSION]->(sub) where sub in nodes(dflow) and array in nodes(dflow)}
})
return distinct  c as call, c.startLine as sline, c.endLine as eline, c.startColumn as scol, c.endColumn as ecol, c.artifact as file, c.name as name