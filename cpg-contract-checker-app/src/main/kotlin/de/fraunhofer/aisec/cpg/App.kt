/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package de.fraunhofer.aisec.cpg;

import de.fraunhofer.aisec.cpg.frontends.solidity.EOGExtensionPass
import de.fraunhofer.aisec.cpg.frontends.solidity.SolidityLanguageFrontend
import de.fraunhofer.aisec.cpg.frontends.solidity.nodes.checks.Check
import de.fraunhofer.aisec.cpg.frontends.solidity.nodes.checks.ReentrancyCheck
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.helpers.Benchmark
import de.fraunhofer.aisec.cpg.helpers.SubgraphWalker
import de.fraunhofer.aisec.cpg.passes.EvaluationOrderGraphPass
import org.neo4j.configuration.GraphDatabaseSettings.DEFAULT_DATABASE_NAME
import org.neo4j.configuration.connectors.BoltConnector
import org.neo4j.configuration.helpers.SocketAddress
import org.neo4j.dbms.api.DatabaseManagementService
import org.neo4j.dbms.api.DatabaseManagementServiceBuilder
import org.neo4j.driver.AuthTokens
import org.neo4j.driver.GraphDatabase
import org.neo4j.driver.Record
import org.neo4j.driver.Transaction
import org.neo4j.graphdb.GraphDatabaseService
import org.neo4j.ogm.config.Configuration
import org.neo4j.ogm.session.SessionFactory
import org.slf4j.LoggerFactory
import picocli.CommandLine
import java.io.File
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.util.stream.Collectors


class App{

    private val logger = LoggerFactory.getLogger(App::class.java)

    @CommandLine.Option(names = ["--neo4j-password"], description = ["The Neo4j password"])
    var neo4jPassword: String = "password"
    var checks: MutableList<Check> = mutableListOf()

    var findings: MutableMap<String, MutableList<String>> = mutableMapOf()


    companion object {
        val log = LoggerFactory.getLogger(App::class.java)

    }

    fun start() {
        registerChecks()
        findings["Empty translation"] = mutableListOf()
        var nr_checked_files = 0
        val base = "/home/kweiss/solsnip/modgrammar"
        val files = getAllSolFiles(base)
        for(path in files){
            println(path.toString())
            val tr: TranslationResult= getGraph(path.toString())
            tr.translationUnits.forEach {
               if(SubgraphWalker.flattenAST(it).size <= 1){
                   findings["Empty translation"]!!.add(it.name)
               }
            }
            persistGraph(tr)
            runVulnerabilityChecks(path.toString())
            nr_checked_files++
            println("Nr. Files: " + nr_checked_files)
        }
        findings.forEach { (k,v) ->
            println(k + " size: " + v.size)
            v.forEach { e ->
                println(e)
                }
        }
    }

    fun getAllSolFiles(path: String): MutableList<Path>{
        val path = Paths.get(path)
        return Files.walk(path)
            .filter { item -> Files.isRegularFile(item) }
            .filter { item -> item.toString().endsWith(".sol") }.collect(Collectors.toList())
    }

    fun getGraph(filename: String) : TranslationResult{
        val basePath = "/home/kweiss/solsnip"
        val base = "base"
        val modgrammar = "modgrammar"
        var path = "cpg-solidity/src/test/resources/examples/Reentrancy.sol"
        path = filename
        val config =
            TranslationConfiguration.builder()
                .topLevel(File(path))
                .sourceLocations(File(path))
                .defaultPasses()
                .registerLanguage(
                    SolidityLanguageFrontend::class.java,
                    SolidityLanguageFrontend.SOLIDITY_EXTENSIONS
                )
                .registerPass(EOGExtensionPass())
                .debugParser(true)
                .processAnnotations(true)
                .build()

        val oldEOGIndex = config.registeredPasses.indexOfFirst {  it is EvaluationOrderGraphPass}
        val newEOGIndex = config.registeredPasses.indexOfFirst {  it is EOGExtensionPass}

        config.registeredPasses[oldEOGIndex ] = config.registeredPasses[ newEOGIndex ]
        config.registeredPasses.removeAt(newEOGIndex)

        val analyzer = TranslationManager.builder().config(config).build()
        val o = analyzer.analyze()
        return o.get()
    }

    fun registerChecks(){
        checks.add(ReentrancyCheck())
    }

    fun persistGraph(result: TranslationResult){
        val configuration =
            Configuration.Builder()
                .uri("bolt://localhost")
                .autoIndex("none")
                .credentials("neo4j", neo4jPassword)
                .build()

        val sessionFactory =
            SessionFactory(configuration, "de.fraunhofer.aisec.cpg.graph", "de.fraunhofer.aisec.cpg.frontends.solidity")
        val session = sessionFactory.openSession()

        session.beginTransaction().use { transaction ->
            session.purgeDatabase()

            val b = Benchmark(App::class.java, "Saving nodes to database")
            /*result.translationUnits.forEach {
                println("Saving file:" + it.name)
                session.save(it)
            }*/

            val nodes = mutableListOf<Node>()
            nodes.addAll(result.additionalNodes)
            nodes.addAll(result.translationUnits)

            session.save(result.translationUnits)
            result.translationUnits.forEach {
                log.info(it.name)
                session.save(it)
                                                                                                                                                                                                                                                                                                                                                                                        }

            b.stop()

            transaction.commit()
        }

        session.clear()
        sessionFactory.close()
    }

    fun runVulnerabilityChecks(filename: String){
        GraphDatabase.driver("bolt://localhost:7687", AuthTokens.basic("neo4j", neo4jPassword)).use { driver ->
            driver.session().use { session ->
                session.readTransaction() { t: Transaction ->

                    for (check in checks){
                        var finding = check.check(t)
                        if(finding){
                            if(findings[check.javaClass.simpleName] == null){
                                findings.put(check.javaClass.simpleName, mutableListOf())
                            }
                            findings[check.javaClass.simpleName]!!.add("Vulnerabillity found in: " + filename)
                            println(check.javaClass.simpleName + " found vulnerability in file:" + filename)
                        }
                    }


                }
            }
        }
    }
}



fun main() {
    val app = App()
    app.start()
    System.exit(0)
}

val TranslationResult.additionalNodes: MutableList<Node>
    get() =
        this.scratch.computeIfAbsent("additionalNodes") { mutableListOf<Node>() } as
                MutableList<Node>


operator fun TranslationResult.plusAssign(node: Node) {
    if(!this.additionalNodes.contains(node))
        this.additionalNodes += node
}
