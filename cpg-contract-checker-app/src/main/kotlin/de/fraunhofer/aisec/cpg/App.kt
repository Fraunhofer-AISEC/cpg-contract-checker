/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package de.fraunhofer.aisec.cpg;

import de.fraunhofer.aisec.cpg.checks.*
import de.fraunhofer.aisec.cpg.frontends.solidity.DFGExtensionPass
import de.fraunhofer.aisec.cpg.frontends.solidity.EOGExtensionPass
import de.fraunhofer.aisec.cpg.frontends.solidity.GraphExtensionsPass
import de.fraunhofer.aisec.cpg.frontends.solidity.SolidityLanguageFrontend
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.helpers.Benchmark
import de.fraunhofer.aisec.cpg.helpers.SubgraphWalker
import de.fraunhofer.aisec.cpg.passes.EvaluationOrderGraphPass
import org.codehaus.jettison.json.JSONObject
import org.codehaus.jettison.json.JSONTokener
import org.eclipse.jetty.util.ajax.JSON
import org.neo4j.driver.AuthTokens
import org.neo4j.driver.GraphDatabase
import org.neo4j.driver.Transaction
import org.neo4j.ogm.config.Configuration
import org.neo4j.ogm.session.SessionFactory
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import picocli.CommandLine
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths
import java.util.concurrent.Callable
import java.util.stream.Collectors
import kotlin.reflect.full.createInstance
import kotlin.system.exitProcess
import kotlin.system.measureTimeMillis


class App : Callable<Int> {

    private val logger = LoggerFactory.getLogger(App::class.java)

    private val compDurations: MutableMap<String, Long> = mutableMapOf()

    private val PRINT_ON_FIND = true


    @CommandLine.Parameters(
        arity = "0..*",
        description =
        ["The files to analyze."]
    )
    var files: List<String> = mutableListOf()

    @CommandLine.Option(
        names = ["--verify-checks", "-vc"],
        description = ["Provide a comma separated list of checks"]
    )
    var optInChecks:String= ""

    @CommandLine.Option(names = ["--neo4j-password"], description = ["The Neo4j password"])
    var neo4jPassword: String = "password"
    var checks: MutableList<Check> = mutableListOf()
    var avChecks: MutableList<Check> = mutableListOf()

    var findings: MutableMap<String, MutableList<String>> = mutableMapOf()



    private val log: Logger
        get() = LoggerFactory.getLogger(App::class.java)

    override fun call(): Int {
        registerChecks()
        var nr_checked_files = 0
        if(files.isEmpty()){
            files = files.flatMap { getAllSolFiles(it) }
            // files = listOf<Path>(Path.of(base + "/" + "66617876_2.sol"))
            // files = listOf<Path>(Path.of("/home/kweiss/coding/cpg-contract-checker/cpg-solidity/src/test/resources/examples/" + "SelfDestruct.sol"))
        }
        for(path in files){
            println(path)
            val start = System.currentTimeMillis()
            val tr= getGraph(path)
            var duration = System.currentTimeMillis() - start
            compDurations["Graph translation"] = compDurations["Graph translation"]?:0 + duration
            tr.translationUnits.forEach {
                if(SubgraphWalker.flattenAST(it).size <= 4){
                    if(!findings.containsKey("Empty translation")){
                        findings["Empty translation"] = mutableListOf()
                    }
                    findings["Empty translation"]!!.add(it.name)
                }
            }
            duration = measureTimeMillis {
                persistGraph(tr)
            }
            compDurations["Persisting graph"] = compDurations["Persisting graph"]?:0 + duration
            println("Running checks")
            duration = measureTimeMillis {
                runVulnerabilityChecks(path)
            }
            compDurations["All checks"] = compDurations["All checks"]?:0 + duration
            nr_checked_files++
            println("Nr. Files: " + nr_checked_files)
        }
        findings.forEach { (k,v) ->
            println("File: " + k)
            v.forEach { e ->
                println("- " + e)
            }
        }
        var durationsString = ""
        compDurations.forEach {(k,v) ->
            durationsString += k + ": " + v + " ms, "
        }
        print(durationsString.dropLast(2) + "\n")
        return 0
    }

    fun getAllSolFiles(path: String): MutableList<String>{
        val path = Paths.get(path)
        return Files.walk(path)
            .filter { item -> Files.isRegularFile(item) }.map{it.toString()}
            .filter { item -> item.endsWith(".sol") }.collect(Collectors.toList())
    }

    fun getGraph(filename: String) : TranslationResult{
        updateChecks(filename)
        var path = filename
        val config =
            TranslationConfiguration.builder()
                .topLevel(File(path))
                .sourceLocations(File(path))
                .defaultPasses()
                .registerLanguage(
                    SolidityLanguageFrontend::class.java,
                    SolidityLanguageFrontend.SOLIDITY_EXTENSIONS
                )
                .registerPass(EOGExtensionPass())
                .registerPass(DFGExtensionPass())
                .registerPass(GraphExtensionsPass())
                .debugParser(true)
                .processAnnotations(true)
                .build()

        val oldEOGIndex = config.registeredPasses.indexOfFirst {  it is EvaluationOrderGraphPass}
        val newEOGIndex = config.registeredPasses.indexOfFirst {  it is EOGExtensionPass}

        config.registeredPasses[oldEOGIndex ] = config.registeredPasses[ newEOGIndex ]
        config.registeredPasses.removeAt(newEOGIndex)

        val analyzer = TranslationManager.builder().config(config).build()
        val o = analyzer.analyze()
        return o.get()
    }

    fun registerChecks(){

            avChecks.add(AccessControlSelfdestructCheck())
            avChecks.add(CallReturnCheck())
            avChecks.add(AccessControlLogicCheck())
            avChecks.add(ReentrancyCheck())
            avChecks.add(DefaultProxyDelegateCheck())
            avChecks.add(TXOriginCheck())
            avChecks.add(DOSCheck())
            avChecks.add(TimeManipulationCheck())
            avChecks.add(AddressPaddingCheck())
            avChecks.add(FrontRunningCheck())
            avChecks.add(LocalWriteToStorageCheck())
            avChecks.add(DOSThroughExhaustionCheck())
            avChecks.add(BadRandomnessCheck())
            avChecks.add(OverUnderflowCheck())

    }

    fun updateChecks(filename: String){
        checks.addAll(avChecks)
        val checkfile =object {}.javaClass.getResourceAsStream("/contract_checks_verify.json")?.bufferedReader()?.readText()
        var jsonObject = JSONTokener(checkfile).nextValue() as JSONObject
        if(jsonObject.has(filename.substringAfter("source-code/"))){
            var jsonChecks = jsonObject.getJSONArray(filename.substringAfter("source-code/"))
            jsonChecks?.let {
                optInChecks = ""
                for(i in 0 until jsonChecks.length()){
                    optInChecks =optInChecks +  jsonChecks[i] + ","
                }
                optInChecks= optInChecks.trim(',')
            }
        }
        if(optInChecks.isNotEmpty()){
            val avChecks = checks.toList()
            checks.clear()
            val checkstrings = optInChecks.split(",").map { it.trim()}
            for ( check in checkstrings){
                val checkclass = avChecks.filter { it::class.simpleName.equals(check) }.firstOrNull()
                if(checkclass != null){
                    checks.add(checkclass)
                }else{
                    log.error("Check wit name $check does not exist.")
                }
            }
        }
    }

    fun persistGraph(result: TranslationResult){
        val configuration =
            Configuration.Builder()
                .uri("bolt://localhost")
                .autoIndex("none")
                .credentials("neo4j", neo4jPassword)
                .build()

        val sessionFactory =
            SessionFactory(configuration, "de.fraunhofer.aisec.cpg.graph", "de.fraunhofer.aisec.cpg.frontends.solidity")
        val session = sessionFactory.openSession()

        session.beginTransaction().use { transaction ->
            session.purgeDatabase()

            val b = Benchmark(App::class.java, "Saving nodes to database")
            result.translationUnits.forEach {
                println("Saving file:" + it.name)
            }

            val nodes = mutableListOf<Node>()
            nodes.addAll(result.additionalNodes)
            nodes.addAll(result.translationUnits)

            session.save(nodes)

            transaction.commit()
            b.stop()
        }

        session.clear()
        sessionFactory.close()
    }

    fun runVulnerabilityChecks(filename: String){
        val printedFiles = mutableListOf<String>()
        GraphDatabase.driver("bolt://localhost:7687", AuthTokens.basic("neo4j", neo4jPassword)).use { driver ->
            driver.session().use { session ->
                session.readTransaction() { t: Transaction ->
                        for (check in checks) {
                            var foundFinding = false
                            val duration = measureTimeMillis {
                                var checkFindings = check.check(t)
                                if (checkFindings.isNotEmpty()) {
                                    if (findings[filename] == null) {
                                        findings.put(filename, mutableListOf())
                                    }
                                    checkFindings.forEach {
                                        val finding = check.getVulnerabilityName() + ", " + it.artifactLocation.toString().substringAfter("file:") + " " + it.region.toString()
                                        foundFinding = true
                                        if(PRINT_ON_FIND){
                                            if(!printedFiles.contains(filename)){
                                                println("File: " + filename)
                                            }
                                            println("- " + finding)
                                        }else{
                                            findings[filename]!!.add(finding)
                                        }

                                    }
                                }
                            }
                            compDurations[check.javaClass.simpleName] = duration
                            println(check.javaClass.simpleName + " took " + duration + " ms")
                            if(optInChecks.isNotEmpty() && foundFinding){
                                println("Verified: " + check::class.simpleName)
                            }
                        }
                }
            }
        }
    }
}

/**
 * Starts a command line application of the cpg-solidity tool.
 */
fun main(args: Array<String>) {
    val exitCode = CommandLine(App()).execute(*args)
    exitProcess(exitCode)
}

val TranslationResult.additionalNodes: MutableList<Node>
    get() =
        this.scratch.computeIfAbsent("additionalNodes") { mutableListOf<Node>() } as
                MutableList<Node>


operator fun TranslationResult.plusAssign(node: Node) {
    if(!this.additionalNodes.contains(node))
        this.additionalNodes += node
}
